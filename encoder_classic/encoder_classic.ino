/***********System Setup Config**************************/
#define W_FINAL   (20.0f)//with zero load, final radias speed, r/s
#define WHEEL_MASS  (0.04f)//kg
#define WHEEL_R     (0.04f)//meter
#define BAT_V       (12.0f)//V
#define MOTO_R       (1.0f)//ohm

/***************************************************/
#define WHEEL_J   (WHEEL_MASS * WHEEL_R * WHEEL_R / 2)//moment of inertia
#define MOTO_K    (BAT_V / W_FINAL)//constant of motor
/***************************************************/
#define MOTO_I(v, w)   ((v - (MOTO_K * w)) / MOTO_R)//v is the volt on motor, w is radia speed
#define MOTO_T(v, w)   (MOTO_K * MOTO_I(v, w))//the toque generated by motor
#define WHEEL_T(v, w, t)  (MOTO_T(v, w) - t)//The net torque on wheel, t is the load torque
#define DELTA_W(v, w, t, time) ((WHEEL_T(v, w, t) / WHEEL_J) * time)//in specific time, how radius speed change
#define DELTA1_W(v, w, t, time)     ((MOTO_K * v * (time) - (MOTO_R * t * (time))) / (WHEEL_J * MOTO_R + (MOTO_K * MOTO_K * (time))))
/**Simple Const****/
#define K   (MOTO_K)
#define R   (MOTO_R)
#define J   (WHEEL_J)
//from 0 speed, with fix volt and toque load, spend time, the RadiusSpeed will be
#define RadiusSpeed(v, T, time)     (((K*v*time) - (R*T*time)) / ((J*R) + (K*K*time)))
//from 0 speed, with fix volt and toque load, to reach RadiusSpeed, how much time will spend
#define TimeFromW(v, T, w)          ((J*R*w) / ((K*v) - (R*T) - (w*K*K)))

/*************************Classic Encoder related*********************/
#define PULS_PER_R      (20)//define how many puls will be genrated per round
#define NEXT_PULS_TIME(w)  (1/(w * PULS_PER_R))

#define ENCODE_PIN        (11)
#define INT0_PIN          (2)
#define INPUTCAPTURE_PIN  (8)

#define TIMER2_TICK     (64)//us
#define TIMER2_FULLTIME (TIMER2_TICK * 256)//us

#define PULSE_LEN       (100)//the output pulse in us

#define TIMER1_TICK     (4)//us
#define PWM_SAMPLE_NUM   (10)//the sample number of pwm duty cycle, to calculate the average sample

unsigned long timer2_overflow_count = 0;
unsigned long timer2_overflow_count_ref = 0;
unsigned char timer2_remain_ref = 0;
unsigned long shadow_timer2_overflow_count_ref = 0;
unsigned char shadow_timer2_remain_ref = 0;
volatile bool isReadyChangeTimer2 = false; //trigger to change the timer0 time
volatile bool isPinToggled = false;//if OC2A is set to high
float pwm_duty_average = 0.0;
unsigned char pwm_sample_count = 0;//count of pwm received sample, when reach to PWM_SAMPLE_NUM, it will not change
unsigned int pwm_sample_count_per_cycle = 0;//the count of pwm received sample, for each loop cycle(10ms)
unsigned int no_pwm_cycle_count = 0;//count how many cycles pwm has not come

void set_timer2_period(unsigned long p_us) {
  cli();//disable interrupt
  if(isReadyChangeTimer2) {//incase the last timer set is not loaded by timer
    isReadyChangeTimer2 = false;
  }
  sei();//enable interrupt

  shadow_timer2_overflow_count_ref = p_us / TIMER2_FULLTIME;
  shadow_timer2_remain_ref = (p_us % TIMER2_FULLTIME) / TIMER2_TICK;
  isReadyChangeTimer2 = true;
}

inline void Timer2_LoadTime(void) {
  if(isReadyChangeTimer2) {
    timer2_overflow_count = 0;
    timer2_overflow_count_ref = shadow_timer2_overflow_count_ref;
    timer2_remain_ref = shadow_timer2_remain_ref;
    isReadyChangeTimer2 = false;

    if(timer2_overflow_count_ref == 0) {
      TCNT2 = 0xff - timer2_remain_ref;
    }
  }
}

inline void timer2_start(void) {
  TCCR2B = 0x07;//1024 prescale, 16Mhz/1024; period = 64us
}

inline void timer2_stop(void) {
  TCCR2B = 0;//no clock source select, stop timer
}

volatile unsigned short pwm_rise_timercout = 0;
volatile unsigned short pwm_fall_timercout = 0;
unsigned short pwm_rise_timercout_copy = 0;
unsigned short pwm_fall_timercout_copy = 0;
unsigned short pwm_rise_timercout_copy_prev = 0;
volatile bool is_pwm_fall = true;
bool is_pwm_timecout_copied = false;
volatile bool is_pwm_timecout_handled = true;
bool is_not_first_pwm = false;

void PWM_RisingEdge(void) {
  //only when a falling edge is detected, then register rise edge, to avoid noise glitch
  if(is_pwm_fall) {
    pwm_rise_timercout = TCNT1;
    is_pwm_fall = false;
  }
}

inline void PWM_FallingEdge(void) {
  pwm_fall_timercout = TCNT1;
  is_pwm_fall = true;
  is_pwm_timecout_handled = false;
}

//arduino clock 16MHz
//not able to use timer0 because arduino is using timer0 for millis() and micros() in wiring.c
void setup() {
  // put your setup code here, to run once:
  Serial.begin(9600);

  //ext interrupt pin, externally connect to a 10k ohm pull down resistor
  pinMode(INT0_PIN, INPUT);
  //enable INT0 interrupt, by rising edge
  attachInterrupt(digitalPinToInterrupt(INT0_PIN), PWM_RisingEdge, RISING);
  //input capture pin to timer1, shall connect to INT0_PIN
  pinMode(INPUTCAPTURE_PIN, INPUT);

  //output pin for encode signal
  pinMode(ENCODE_PIN, OUTPUT);
  digitalWrite(ENCODE_PIN, LOW);
  //using Timer 2, 8bit, normal mode, going to Toggle OC2A Pin, D11 pin in arduino
  TCCR2A = 0x00;//not Toggle OC2A Pin
  TCCR2B = 0;//no clock source select, stop timer
  TIMSK2 = 0x03;//enable interrupt for OCIE2A and TimerOverFlow
  ASSR = 0; //use 16MHz clock
  TCNT2 = 0;

  //Accroding to https://lastminuteengineers.com/arduino-nano-pinout/
  //Arduino using timer0, default configure is 1024 prescale, normal more

  //Input Capture ICP1->PB0->D8 pin arduino
  //Configure Timer1 as normal mode, 
  TCCR1A = 0x00;
  TCCR1B = 0x83;//with filter, trigger in falling edge, 1/64 prescale, 4us per tick
  TIMSK1 = 0x20;//Enable interrupt of Input Capture

  sei();//allow interrupts

  //Testing code, set timer0 to 100ms
  //set_timer2_period(100000);
  //Timer2_LoadTime();
  //timer2_start();
}

inline void Timer2_Timeup(void) {
  Timer2_LoadTime();
  timer2_start();

  digitalWrite(ENCODE_PIN, LOW);//set OC2A high
  isPinToggled = true;
  OCR2A = TCNT2 + (PULSE_LEN / TIMER2_TICK);//output compare register set to pulse length
  TCCR2A = 0xC0;//clean OC2A Pin setting
}

//ISR for timer0 over flower
ISR(TIMER2_OVF_vect){
  if(timer2_overflow_count_ref == 0) {//situation when only one overflow is needed
    TCNT2 = 0xff - timer2_remain_ref;
    Timer2_Timeup();
  }
  else {
    if(timer2_overflow_count >= timer2_overflow_count_ref) {
      timer2_overflow_count = 0;
      TCNT2 = 0xff - timer2_remain_ref;
    }
    else {
      if(timer2_overflow_count == 0) {
        Timer2_Timeup();
      }

      timer2_overflow_count ++;
    }
  }
}


//ISR for timer2 compare A match
ISR(TIMER2_COMPA_vect){
  if(isPinToggled) {
    TCCR2A = 0x00; //no toggle OC2A Pin setting
    isPinToggled = false;
  }
}

int i = 0;
float load_toq = 0.0;
float current_w = 0;//current radias speed
float input_v = 12.0;//input voltage
float pulse_period = 0.0;//us
long pulse_period_i = 0;
#define INTERVAL_TIME     (0.01)//sec

volatile bool is_job_done = false;
bool is_w_too_small = true;
void loop() {
  // put your main code here, to run repeatedly:
  
  //handle PWM input
  cli();//disable interrupt
  if(is_pwm_fall && (!is_pwm_timecout_handled)) {//falling edge is register
    is_pwm_timecout_handled = true;
    if(pwm_rise_timercout && pwm_fall_timercout) {//make sure the first pwm has arrived
      pwm_rise_timercout_copy = pwm_rise_timercout;
      pwm_fall_timercout_copy = pwm_fall_timercout;
      is_pwm_timecout_copied = true;
    }
  }
  sei();//enable interrupt

  if(is_pwm_timecout_copied){
    if(is_not_first_pwm) {
      float current_pwm = 0.0;

      is_pwm_timecout_copied = false;
      pwm_sample_count_per_cycle ++;

      if(no_pwm_cycle_count) {//do not calculate the first pwm come from long time of 100% or 0%
        if(input_v < 0.01) {
          pwm_duty_average = 0;
        }
        else {
          pwm_duty_average = 1;
        }
      }
      else {
        current_pwm = (pwm_fall_timercout_copy - pwm_rise_timercout_copy) / (pwm_rise_timercout_copy - pwm_rise_timercout_copy_prev);
        pwm_duty_average = (pwm_duty_average * pwm_sample_count + current_pwm) / (pwm_sample_count + 1);
      }

      pwm_rise_timercout_copy_prev = pwm_rise_timercout_copy;
      if(pwm_sample_count < PWM_SAMPLE_NUM) {
        pwm_sample_count ++;
      }
    }
    else {
      pwm_rise_timercout_copy_prev = pwm_rise_timercout_copy;
      is_not_first_pwm = true;
    }
  }

  if(millis() % 10) {//run once every 10ms
    bool no_pwm_coming = false;

    if(!is_job_done) {
      is_job_done = true;

      //handle pwm input
      if(pwm_sample_count_per_cycle == 0) {
        no_pwm_coming = true;
        no_pwm_cycle_count ++;
      }
      else {
        no_pwm_cycle_count = 0;
      }
      pwm_sample_count_per_cycle = 0;

      if(no_pwm_coming) {
        if(digitalRead(INPUTCAPTURE_PIN)) {//100% duty cycle
          input_v = BAT_V;
        }
        else {//0 duty cycle
          input_v = 0.0;
        }
      }
      else {
        input_v = BAT_V * pwm_duty_average;
      }

      //Calculate the current radius speed, and the period os the pulse
#if 0      
      current_w = DELTA1_W(input_v, current_w, load_toq, INTERVAL_TIME);
#else      
      float t0 = TimeFromW(input_v, load_toq, current_w);
      current_w = RadiusSpeed(input_v, load_toq, (t0 + INTERVAL_TIME));
#endif      

      if(abs(current_w) > 0.1) {//we only output pulse with radius speed is more than 0.1 round per secound
        pulse_period = (1 / (abs(current_w) * 20.0)) * 1000000.0;//NEXT_PULS_TIME(abs(current_w)) * 1000000;
        pulse_period_i = pulse_period;
        set_timer2_period(pulse_period_i);
                
        //recovery from radius speed is too small
        if(is_w_too_small) {
          Timer2_LoadTime();
          timer2_start();
          is_w_too_small = false;
        }
      }
      else {//w too small, stop the pulse generate
        is_w_too_small = true;
        timer2_stop();
        TCNT2 = 0;
      }

      //Test Code, increase the load toque until max toque
      i ++;
      if(i >= 100) {//every 1 sec
        i = 0;
        //float data = DELTA1_W(BAT_V, current_w, 1, 0.01);//MOTO_T(BAT_V, current_w);
        //data = DELTA_W(BAT_V, data, 0, 0.01);
        
        //Serial.println(current_w);
        Serial.println(input_v);
        //Serial.println(pulse_period_i);
        load_toq += 0.1;
        if(load_toq >= 7) {//MAX Toque is 7.2Nm from Motor
          load_toq = 0;
        }
        
      }
    }
  }
  else {
    is_job_done = false;
  }

}

